name: Update Index

on:
  push:
    branches: ["**"]
  workflow_dispatch:

permissions:
  contents: write

concurrency:
  group: update-index-${{ github.ref }}
  cancel-in-progress: true

jobs:
  update-index:
    runs-on: ubuntu-latest
    env:
      README_PATH: README.md
      INDEX_HEADING: "### üìë Project Index"
      AI_MODEL: gpt-4o-mini
      OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}

    steps:
      - uses: actions/checkout@v4
        with:
          persist-credentials: false
          fetch-depth: 0
          ref: ${{ github.ref }}

      - uses: actions/setup-node@v4
        with:
          node-version: 20

      - name: Write indexer script to file
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .github/tmp
          cat > .github/tmp/update-index.mjs <<'NODE'
          import fs from 'fs';
          import path from 'path';

          const README_PATH   = process.env.README_PATH || 'README.md';
          const INDEX_HEADING = process.env.INDEX_HEADING || '### üìë Project Index';
          const OPENAI_API_KEY = process.env.OPENAI_API_KEY || '';
          const AI_MODEL       = process.env.AI_MODEL || 'gpt-4o-mini';

          if (!fs.existsSync(README_PATH)) {
            console.error(`‚ùå README not found at ${README_PATH}`);
            process.exit(1);
          }

          // ---------- SETTINGS ----------
          const IGNORE = new Set([
            '.git','node_modules','.DS_Store','.idea','.vscode','.env','.venv',
            '.next','dist','build','coverage','.turbo','.cache'
          ]);
          const IMAGE_RX = /\.(png|jpe?g|gif|svg|ico|webp|bmp|tiff|avif)$/i;

          const MAX_SAMPLE_BYTES = 120 * 1024; // give the AI more context (120KB)
          const AI_TIMEOUT_MS = 45000;

          // ---------- HELPERS ----------
          function listDir(abs) {
            return fs.readdirSync(abs, { withFileTypes: true })
              .filter(e => !IGNORE.has(e.name))
              .sort((a, b) => {
                if (a.isDirectory() !== b.isDirectory()) return a.isDirectory() ? -1 : 1;
                return a.name.localeCompare(b.name);
              });
          }

          function safeRead(fileAbs, maxBytes = MAX_SAMPLE_BYTES) {
            try {
              const b = fs.readFileSync(fileAbs);
              const head = b.subarray(0, Math.min(4096, b.length));
              let controlCount = 0;
              for (let i = 0; i < head.length; i++) {
                const byte = head[i];
                if (byte === 0) { controlCount = 9999; break; }
                if (byte < 9 || (byte > 13 && byte < 32)) controlCount++;
              }
              const isBinary = controlCount > 48;
              if (isBinary) return { text: '(binary or non-text content omitted)', isBinary: true, size: b.length };
              return { text: b.toString('utf8', 0, Math.min(b.length, maxBytes)), isBinary: false, size: b.length };
            } catch {
              return { text: '', isBinary: false, size: 0 };
            }
          }

          function quickSignals(sample, rel) {
            const out = {};
            out.functions = Array.from(sample.matchAll(/\bfunction\s+([A-Za-z0-9_]+)/g)).map(m=>m[1]);
            out.exports = Array.from(sample.matchAll(/\bexport\s+(?:default\s+)?(?:function|class|const|let|var)?\s*([A-Za-z0-9_]+)/g)).map(m=>m[1]);
            out.classes = Array.from(sample.matchAll(/\bclass\s+([A-Za-z0-9_]+)/g)).map(m=>m[1]);
            out.hooks = Array.from(sample.matchAll(/\buse(State|Effect|Memo|Callback|Ref|Reducer|Context)\b/g)).map(m=>'use'+m[1]);
            out.routes = Array.from(sample.matchAll(/\b(app|router)\.(get|post|put|delete|patch)\(['"`]([^'"`]+)['"`]\)/g)).map(m=>`${m[2].toUpperCase()} ${m[3]}`);
            out.imports = Array.from(sample.matchAll(/\bfrom\s+['"]([^'"]+)['"]/g)).map(m=>m[1]).slice(0,8);
            out.next = /from\s+['"]next(\/.*)?['"]/.test(sample) || /(?:^|\/)(app|pages)\//.test(rel);
            out.react = /from\s+['"]react['"]/.test(sample) || /tsx?$/i.test(rel);
            out.tailwind = /class(Name)?=/.test(sample) && /(bg-|text-|flex|grid|rounded|shadow|md:|lg:)/.test(sample);
            return out;
          }

          function fallbackDescribe(rel, sample = '') {
            if (IMAGE_RX.test(rel)) return path.posix.basename(rel); // image description = its filename
            const n = rel.toLowerCase();
            if (n.endsWith('/readme.md') || n === 'readme.md') return 'Project documentation with overview, setup and usage.';
            if (n.endsWith('package.json')) return 'Node package manifest defining scripts, dependencies and project metadata.';
            if (/pnpm-lock\.yaml$|yarn\.lock$|package-lock\.json$/.test(n)) return 'Dependency lockfile pinning exact versions for reproducible installs.';
            if (/\.(css|scss|sass)$/i.test(n)) return 'Stylesheet defining layout and utility classes.';
            if (/\.html$/i.test(n)) return 'Static HTML markup for a page or template.';
            if (/\.(ts|tsx|js|jsx)$/i.test(n)) {
              const sig = quickSignals(sample, rel);
              const bits = [];
              if (sig.next) bits.push('Next.js module');
              else if (sig.react) bits.push('React component/module');
              else bits.push('JavaScript/TypeScript module');
              if (sig.exports?.length) bits.push(`exports: ${sig.exports.slice(0,5).join(', ')}${sig.exports.length>5?'‚Ä¶':''}`);
              if (sig.classes?.length) bits.push(`classes: ${sig.classes.slice(0,3).join(', ')}${sig.classes.length>3?'‚Ä¶':''}`);
              if (sig.functions?.length) bits.push(`functions: ${sig.functions.slice(0,5).join(', ')}${sig.functions.length>5?'‚Ä¶':''}`);
              if (sig.hooks?.length) bits.push(`hooks: ${sig.hooks.slice(0,5).join(', ')}${sig.hooks.length>5?'‚Ä¶':''}`);
              if (sig.routes?.length) bits.push(`routes: ${sig.routes.slice(0,3).join(', ')}${sig.routes.length>3?'‚Ä¶':''}`);
              if (sig.imports?.length) bits.push(`imports ${sig.imports.slice(0,4).join(', ')}${sig.imports.length>4?'‚Ä¶':''}`);
              if (sig.tailwind) bits.push('uses Tailwind utilities');
              return bits.join('; ') + '.';
            }
            if (/\.(md|mdx)$/i.test(n)) return 'Markdown content for documentation or pages.';
            if (/\.(json)$/i.test(n)) return 'JSON data or configuration.';
            if (/\.(yml|yaml)$/i.test(n)) return 'YAML configuration (CI/tooling).';
            return 'Repository file.';
          }

          async function aiDescribeFile(relPath, sample) {
            // For images, ALWAYS use the filename as description.
            if (IMAGE_RX.test(relPath)) return path.posix.basename(relPath);
            if (!OPENAI_API_KEY) return fallbackDescribe(relPath, sample);

            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), AI_TIMEOUT_MS);

            const sys =
              "You are a rigorous code indexer. For ONE file, produce a highly accurate, compact summary in 4‚Äì7 sentences (90‚Äì180 words) on ONE LINE. Include: the file‚Äôs role in the app; how it works; notable algorithms/logic; key exports/functions/classes/React components/hooks; important props/state/effects; routes or API endpoints; critical config keys; frameworks used (e.g., Next.js pages/app router conventions, Tailwind utilities). Prefer precise identifiers in backticks (e.g., `handler`, `Home`, `GET /api/foo`). No markdown headers. Do NOT repeat the filename. No disclaimers. Replace newlines with spaces. End with a period.";

            const usr =
              "PATH >> " + relPath + "\n" +
              "CONTEXT >> Next.js/React/Tailwind portfolio repository.\n" +
              "SAMPLE(" + (sample?.length || 0) + " chars) >>\n" +
              (sample || '(empty/binary)') + "\n" +
              "RETURN >> one-line summary with detailed code-level specifics.";

            try {
              const res = await fetch('https://api.openai.com/v1/chat/completions', {
                method: 'POST',
                headers: {
                  'Authorization': `Bearer ${OPENAI_API_KEY}`,
                  'Content-Type': 'application/json'
                },
                body: JSON.stringify({
                  model: AI_MODEL,
                  messages: [
                    { role: 'system', content: sys },
                    { role: 'user', content: usr }
                  ],
                  temperature: 0.05,
                  max_tokens: 320
                }),
                signal: controller.signal
              });

              clearTimeout(timer);

              if (!res.ok) {
                const errTxt = await res.text().catch(()=>String(res.status));
                console.warn(`‚ö†Ô∏è AI describe failed (${res.status}): ${errTxt}`);
                return fallbackDescribe(relPath, sample);
              }
              const data = await res.json();
              const text = data?.choices?.[0]?.message?.content ?? '';
              if (!text.trim()) return fallbackDescribe(relPath, sample);

              let line = text.replace(/\s+/g, ' ').trim();
              if (line.length > 700) line = line.slice(0, 700).trimEnd() + '‚Ä¶';
              if (!/[.!?]$/.test(line)) line += '.';
              return line;
            } catch (e) {
              console.warn(`‚ö†Ô∏è AI describe error: ${e?.message || e}`);
              return fallbackDescribe(relPath, sample);
            }
          }

          async function buildDetailsForDir(rootAbs, relDir) {
            const abs = path.join(rootAbs, relDir);
            const entries = listDir(abs);
            const files = entries.filter(e => e.isFile());
            const dirs  = entries.filter(e => e.isDirectory());

            let html = '';
            if (files.length) {
              html += '      <ul>\n';
              for (const f of files) {
                const relPath = path.posix.join(relDir, f.name).replace(/\\/g, '/');
                // Image rule: description is the filename itself (no AI)
                if (IMAGE_RX.test(f.name)) {
                  const href = path.posix.join('.', relPath);
                  html += `         <li><b><a href="${href}">${f.name}</a></b> ‚Äî ${f.name}</li>\n`;
                  continue;
                }
                const { text: sample } = safeRead(path.join(abs, f.name));
                const desc = await aiDescribeFile(relPath, sample);
                const href = path.posix.join('.', relPath);
                html += `         <li><b><a href="${href}">${f.name}</a></b> ‚Äî ${desc}</li>\n`;
              }
              html += '      </ul>\n';
            }

            for (const d of dirs) {
              const childRel = path.posix.join(relDir, d.name).replace(/\\/g, '/');
              html += '      <details>\n';
              html += `         <summary><b>${d.name}</b></summary>\n`;
              html += await buildDetailsForDir(rootAbs, childRel);
              html += '      </details>\n';
            }

            return html;
          }

          async function buildProjectIndex() {
            const repoName = (process.env.GITHUB_REPOSITORY || '').split('/').pop()
              || path.basename(process.cwd());
            const repoNameUpper = repoName.toUpperCase();

            let out = '';
            out += `${INDEX_HEADING}\n\n`;
            out += '<details open>\n';
            out += `   <summary><b>${repoNameUpper}/</b></summary>\n`;

            const rootEntries = listDir(process.cwd());
            const rootFiles = rootEntries.filter(e => e.isFile());
            if (rootFiles.length) {
              out += '   <details>\n';
              out += '      <summary><b>__root__</b></summary>\n';
              out += '      <ul>\n';
              for (const f of rootFiles) {
                if (IMAGE_RX.test(f.name)) {
                  const href = `./${f.name}`;
                  out += `         <li><b><a href="${href}">${f.name}</a></b> ‚Äî ${f.name}</li>\n`;
                  continue;
                }
                const { text: sample } = safeRead(path.join(process.cwd(), f.name));
                const desc = await aiDescribeFile(f.name, sample);
                const href = `./${f.name}`;
                out += `         <li><b><a href="${href}">${f.name}</a></b> ‚Äî ${desc}</li>\n`;
              }
              out += '      </ul>\n';
              out += '   </details>\n';
            }

            for (const d of rootEntries.filter(e => e.isDirectory())) {
              const rel = d.name;
              out += '   <details>\n';
              out += `      <summary><b>${d.name}</b></summary>\n`;
              out += await buildDetailsForDir(process.cwd(), rel);
              out += '   </details>\n\n';
            }

            out += '\n</details>';
            return out;
          }

          function replaceRangeByHR(readme, newSection) {
            const startIdx = readme.indexOf(INDEX_HEADING);
            if (startIdx === -1) {
              const sep = readme.endsWith('\n') ? '' : '\n';
              return readme + sep + '\n---\n' + newSection + '\n';
            }
            const afterStart = startIdx + INDEX_HEADING.length;
            const after = readme.slice(afterStart);
            const HR_RX = /(?:^|\n)\s*---\s*(?:\n|$)/m;
            const hrMatch = after.match(HR_RX);
            const endIdx = hrMatch ? (afterStart + hrMatch.index) : readme.length;
            const before = readme.slice(0, startIdx);
            const tail = readme.slice(endIdx);
            return before + newSection + tail;
          }

          (async () => {
            const readme = fs.readFileSync(README_PATH, 'utf8');
            const newSection = await buildProjectIndex();
            const updated = replaceRangeByHR(readme, newSection);

            if (updated === readme) {
              console.log('No changes to Project Index.');
              process.exit(0);
            }

            fs.writeFileSync(README_PATH, updated, 'utf8');
            console.log('‚úÖ Project Index updated in README (code-detailed summaries; images use filename).');
          })().catch(e => { console.error('‚ùå Failed:', e); process.exit(1); });
          NODE

      - name: Run indexer
        shell: bash
        run: |
          set -euo pipefail
          node .github/tmp/update-index.mjs

      - name: Commit, rebase on remote, and push
        env:
          PAT_OR_TOKEN: ${{ secrets.PERSONAL_TOKEN || secrets.GITHUB_TOKEN }}
          README_PATH: README.md
        shell: bash
        run: |
          set -euo pipefail

          BRANCH="${GITHUB_REF_NAME:-$(git rev-parse --abbrev-ref HEAD)}"

          git config user.name  "github-actions[bot]"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"

          git remote set-url origin "https://x-access-token:${PAT_OR_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

          if git diff --quiet -- "${README_PATH}"; then
            echo "No changes."
            exit 0
          fi

          git add "${README_PATH}"
          git commit -m "docs: auto-update üìë Project Index with code-detailed summaries (image names only)" || true

          git fetch origin "${BRANCH}"
          git pull --rebase --autostash origin "${BRANCH}" || true

          git add "${README_PATH}" || true
          git diff --cached --quiet || git commit --no-edit || true

          if ! git push origin "HEAD:${BRANCH}"; then
            echo "Push rejected, syncing once and retrying‚Ä¶"
            git fetch origin "${BRANCH}"
            git pull --rebase --autostash origin "${BRANCH}" || true
            git add "${README_PATH}" || true
            git diff --cached --quiet || git commit --no-edit || true
            git push origin "HEAD:${BRANCH}"
          fi
